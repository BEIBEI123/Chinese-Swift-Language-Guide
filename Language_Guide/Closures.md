# 闭包

闭包是可以在代码中传递并使用的独立的功能块。Swift中的闭包与C和Objective-C中的`Block`类似，与其他语言中的拉姆达表达式相似。

闭包可以从其被定义的上下文中，捕获并储存任何变量和常量的引用。这被称为***收起***这些常量和变量。Swift帮你管理所有捕获的内存。

> 注意：
> 如果不懂得捕获这个概念，先别着急。在[值的捕获](#值的捕获)中有解释。

如[函数](Functions.md)中所述，全局和嵌套函数实际上是特殊的闭包。以下三种形式之一，是闭包：
* 全局函数是有名称的闭包，且不捕获任何值
* 嵌套函数是有名称的闭包，且可以从其他函数作用域中捕获值
* 闭包表达式是以轻量语法编写的无名称闭包，可以从其被包围的上下文中捕获值

Swift的闭包表达式具有简洁，清晰的风格，在常用场景中，针对鼓励代码简洁和无杂乱化语法进行优化（吹牛的话不会翻译）。这些优化包括：
* 从上下文中推导参数类型和返回值类型
* 从单个表达式闭包隐式返回
* 速记参数名称
* 尾随闭包语法

## 闭包表达式

如[嵌套函数](Functions.md#嵌套函数)中所述，嵌套函数是一种命名和定义独立功能块，作为更大函数一部分的便利方法。但是，有时候编写较短的没有声明或名称的类函数结构比较有用。当函数或方法需要一个或多个函数作为参数时，这个做法尤为有用。

***闭包表达式*** 是编写内联闭包的简洁，专注的语法。闭包表达式提供了几种以一种简洁但不失清晰度和意图的方法编写闭包的语法优化。下面例子中的闭包表达式通过在遍历中重定义`sorted(by:)`方法，解释这些优化，每个表达式功能相同，但是更简洁。

### 排序方法

Swift标准库提供了一个`sorted(by:)`方法，它基于一个你提供的闭包的输出值，对一个已知类型的数组进行排序。一旦完成排序过程，`sorted(by:)`返回一个与旧数组类型和大小相同，元素排完序的新数组。`sorted(by:)`方法不修改原数组。

下面的闭包表达式用`sorted(by:)`方法按照逆字母顺序对一个字符串数组进行排序。这是原始数组：
```swift
let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
```

`sorted(by:)`方法接受两个与数组类型相同的参数，返回一个布尔值，表明在排序比较中，第一个值否会排在第二个值的后面或前面。如果第一个值应该排在第二个值的前面，则排序闭包需要返回`true`，否则返回`false`。

这个例子排序一个字符串数组，排序闭包需要是`(String, String) -> Bool`类型的函数。

一个提供排序闭包的方法是，编写该类型的函数，然后将函数作为参数传递给`sorted(by:)`方法：
```swift
func backward(_ s1: String, _ s2: String) -> Bool {
  return s1 > s2
}
var reversedNames = names.sorted(by: backward)
// reversedNames is equal to ["Ewa", "Daniella", "Chris", "Barry", "Alex"]
```

如果第一个字符串(`s1`)比第二个字符串(`s2`)大，`backward(_:_:)`函数返回`true`，表明在排完序的数组中`s1`应该出现在`s2`的前面。对于字符串中的字符，“大于”的意思是“在字母表中靠后”。这意味着字母`B`比字母`A`要大，字符串`Tom`要比字符串`Tim`大。这里逆序排序，`"Barry"`在`"Alex"`前面，等等。

但是，对比可以写成简单表达式（`a > b`），上面是一种冗长的写法。这个例子中，应该首选用闭包表达式语法，写内联排序闭包。

### 闭包表达式语法

闭包表达式语法有如下通用格式：
```swift
  { (`parame`) -> `return type` in  
      `statements`  
  }
```

闭包表达式语法中的参数可以是`in-out`型参数，但是不能有默认值。也可用可变参数。元组也可被用作参数类型和返回类型。

下面的例子展示了上例中`backward(_:_:)`函数的闭包表达式版本：
```swift
  reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in
    return s1 > s2
  })
```

注意这个内联闭包的参数和返回值类型与`backward(_:_:)`函数相同。在这两个例子中，被写作`(s1: String, s2: String) -> Bool`。但是，对于闭包表达式，参数和返回值类型写在小括号里面，而不是外面。

闭包主体的开头有`in`关键字引入。这个关键字表明闭包的参数和返回值定义已经结束，闭包主体要开始。

因为闭包的主体很短，上面的代码可以写成一行：
```swift
reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 > s2})
```

这说明对`sorted(by:)`方法的整体调用保持不变。一对括号括起了方法的所有参数。但，此时参数是内联闭包的。

### 从上下文推导类型

因为排序闭包被作为参数传递给方法，Swift可以推导参数和返回值的类型。`sorted(by:)`方法被字符串数组调用，所以其参数应该是`(String, String) -> Bool`类型的函数。这意味着不必将`(String, String)`和`Bool`写成闭包表达式定义的一部分。因为所有的类型都可以被推导出来，返回值箭头(`->`)和参数的括号都可以省略：
```swift
reversedNames = names.sorted(by: { s1, s2 in return s1 > s2 })
```
当把闭包作为内联闭包表达式传递给函数或方法时，总能推导出参数和返回值的类型。因此，但把闭包用作函数或方法的参数是，你永远不需要写内联闭包的完整格式。

尽管如此，如果你愿意你可以让类型明显，如果这能让读者或代码避免歧义，应该鼓励这么做。


 ## 单行闭包表达式隐式返回值
 
























[< 函数](Functions.md) || [枚举 >](Enumeration.md)
